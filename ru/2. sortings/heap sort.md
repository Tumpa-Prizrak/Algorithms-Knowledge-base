# Heap sort
```cpp
void heapify(int arr[], int N, int i)
{
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;

    if (l < N && arr[l] > arr[largest])
        largest = l;
    if (r < N && arr[r] > arr[largest])
        largest = r;

    if (largest != i) {
        swap(arr[i], arr[largest]);

        heapify(arr, N, largest);
    }
}

void heapSort(int arr[], int N)
{
    for (int i = N / 2 - 1; i >= 0; i--)
        heapify(arr, N, i);

    for (int i = N - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

# Вот как работает эта функция

1. Сначала она преобразует массив в кучу, вызывая heapify() на всех нелистовых узлах.
2. Затем она извлекает максимальный элемент из кучи, меняя его местами с последним элементом.
3. Он снова вызывает heapify() на новом корневом элементе, чтобы сохранить свойство кучи.
4. Повторяет шаги 2 и 3, пока в куче не останется 1 элемент.

# Пример
```py
Входной массив: [5, 3, 8, 1, 4, 2, 9, 6]
```
1. Вызываем heapify() на индексах 3, 2 и 1 для преобразования в максимальную кучу. Куча: [9, 8, 5, 1, 4, 2, 3, 6].
2. Поменяйте местами 9 и 8. Вызовите heapify() на индексе 0. Куча: [8, 6, 5, 1, 4, 2, 3].
3. Поменяйте местами 8 и 6. Вызвать heapify() на индексе 0. Куча: [6, 5, 3, 1, 4, 2]
4. Поменяйте местами 6 и 5. Вызвать heapify() на индексе 0. Куча: [5, 3, 2, 1, 4]
5. Поменяйте местами 5 и 4. Вызвать heapify() на индексе 0. Куча: [4, 3, 2, 1]
6. Поменяйте местами 4 и 3. Вызовите heapify() на индексе 0. Куча: [3, 2, 1].
7. Поменяйте местами 3 и 2. Вызовите heapify() на индексе 0. Куча: [2, 1].
8. Поменять местами 2 и 1. Вызвать heapify() по индексу 0. Куча: [1]

## Некоторые ключевые моменты о Heap sort

- Это алгоритм in-place, то есть он сортирует массив на месте без использования вспомогательного пространства.
- Это не стабильная сортировка, то есть первоначальный порядок элементов с одинаковыми ключами может измениться.
- Он работает, сначала организуя массив в структуру данных кучи. Затем он многократно извлекает максимальный элемент из кучи и помещает его в конец массива.
- Куча представляет собой полное двоичное дерево со свойством кучи: для каждого узла ключ в этом узле больше или равен ключам в его дочерних элементах (если они существуют).
- Построение кучи занимает O(n) времени. Извлечение каждого элемента занимает O(logn) времени. Таким образом, общая временная сложность составляет O(nlogn).
- Пространственная сложность составляет O(1), поскольку сортировка выполняетсяin-place.
- Кучная сортировка является хорошим выбором, когда пространство памяти ограничено.

В итоге, Heap sort - это эффективный алгоритм сортировки на месте с временной сложностью O(nlogn). Он работает, сначала организуя массив в кучу, а затем многократно извлекая максимальный элемент из кучи и помещая его в конец массива.
