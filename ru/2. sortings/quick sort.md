# Quick sort
```cpp
int partition(int arr[], int low, int high)
{
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high)
{
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

# Вот как работает эта функция

Функция partition() выбирает последний элемент в качестве стержня.
- Если arr[j] < pivot, то функция меняет местами arr[i+1 и arr[i+1].
- - Если arr[j] < pivot, она меняет местами arr[i+1] и arr[j] и увеличивает i.
- - Это продолжается до тех пор, пока j не достигнет high - 1. В конце поворотная точка меняется местами с arr[i+1].
- - Финальный индекс i возвращается.
<br><br>
- Затем функция quicksort() рекурсивно вызывает саму себя для сортировки левого и правого разделов.
- - Левый раздел - от low до pi - 1.
- - Правый раздел - от pi + 1 до high.
- - Этот процесс продолжается до тех пор, пока массив не будет отсортирован.

Временная сложность quicksort составляет *O(N log N)*.

## Вот ключевые моменты о Quicksort:

- Сортировка Quicksort - это алгоритм "разделяй и властвуй". It picks an element as pivot and partitions the list around the pivot such that all elements with values less than the pivot come before it, and all elements with values greater than the pivot come after it.

- Это не стабильный алгоритм сортировки, то есть он не сохраняет исходный порядок элементов с одинаковыми ключами.

- средняя временная сложность составляет O(nlogn), а наихудшая временная сложность - O(n2). The space complexity is O(logn) due to recursion stack.

- Quicksort является хорошим выбором, когда:
    - Необходим быстрый алгоритм сортировки.
    - Стабильность не важна.

- Он работает путем выбора стержневого элемента, разбиения списка вокруг стержня таким образом, что все элементы со значениями меньше стержня идут перед ним, а все элементы со значениями больше стержня идут после него. Затем список разбивается рекурсивно.

- Код состоит из двух функций:
    - quicksort() - основная рекурсивная функция, которая разбивает список.
    - partition() - разбивает список вокруг поворотного элемента.

- Функция quicksort() выбирает стержень, разбивает список вокруг него и рекурсивно вызывает саму себя для сортировки двух разделов.

- Quicksort - это быстрый рекурсивный алгоритм сортировки со средней временной сложностью O(nlogn). Он работает путем выбора стержневого элемента, разбиения списка вокруг стержня таким образом, что все элементы со значениями меньше стержня оказываются перед ним, а все элементы со значениями больше стержня оказываются после него. Затем список разбивается рекурсивно.

- Наихудший случай возникает, когда стержнем является наименьший или наибольший элемент, что приводит к временной сложности O(n2). Этого можно избежать, выбрав случайный стержень.

- Quicksort - хороший выбор, когда требуется быстрый, эффективный алгоритм сортировки, а стабильность не важна. Пространственная сложность составляет O(logn) из-за стека рекурсий.