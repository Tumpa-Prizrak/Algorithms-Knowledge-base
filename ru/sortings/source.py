# auto-generated by Cody. Be carefull
def partition(arr, low, high): 
    # Choosing the pivot 
    pivot = arr[high] 

    # Index of smaller element 
    i = low - 1

    for j in range(low, high): 

        # If current element is smaller than the pivot
        if arr[j] < pivot: 

            # Increment index of smaller element
            i += 1
            arr[i], arr[j] = arr[j], arr[i] 

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1

# The main function that implements QuickSort
def quick_sort(arr, low, high): 
    if low < high: 

        # pi is partitioning index, arr[p] 
        # is now at right place 
        pi = partition(arr, low, high)

        # Separately sort elements before 
        # partition and after partition 
        quick_sort(arr, low, pi-1) 
        quick_sort(arr, pi+1, high)


# Merges two subarrays of array[].
# First subarray is arr[begin..mid]
# Second subarray is arr[mid+1..end]
def merge(array, left, mid, right):
    subArrayOne = mid - left + 1
    subArrayTwo = right - mid

    # Create temp arrays
    leftArray = [0] * subArrayOne 
    rightArray = [0] * subArrayTwo 

    # Copy data to temp arrays leftArray[] and rightArray[]
    for i in range(subArrayOne):
        leftArray[i] = array[left + i]
    for j in range(subArrayTwo):
        rightArray[j] = array[mid + 1 + j]

    indexOfSubArrayOne = 0
    indexOfSubArrayTwo = 0
    indexOfMergedArray = left

    # Merge the temp arrays back into array[left..right]
    while indexOfSubArrayOne < subArrayOne and indexOfSubArrayTwo < subArrayTwo: 
        if leftArray[indexOfSubArrayOne] <= rightArray[indexOfSubArrayTwo]:
            array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]
            indexOfSubArrayOne += 1
        else:
            array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]
            indexOfSubArrayTwo += 1
        indexOfMergedArray += 1

    # Copy the remaining elements of left[], if there are any 
    while indexOfSubArrayOne < subArrayOne: 
        array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]
        indexOfSubArrayOne += 1
        indexOfMergedArray += 1

    # Copy the remaining elements of right[], if there are any 
    while indexOfSubArrayTwo < subArrayTwo:
        array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]
        indexOfSubArrayTwo += 1
        indexOfMergedArray += 1

# begin is for left index and end is right index
# of the sub-array of arr to be sorted
def merge_sort(array, begin, end):
    if begin >= end:
        return
    mid = begin + (end - begin) // 2
    merge_sort(array, begin, mid)
    merge_sort(array, mid + 1, end)
    merge(array, begin, mid, end)

# To heapify a subtree rooted with node i 
# which is an index in arr[]. 
# n is size of heap
def heapify(arr, n, i):
    largest = i # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # If left child is larger than root
    if l < n and arr[l] > arr[largest]:
        largest = l

    # If right child is larger than largest so far
    if r < n and arr[r] > arr[largest]:
        largest = r

    # If largest is not root
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i] # swap

        # Recursively heapify the affected sub-tree
        heapify(arr, n, largest)

# Main function to do heap sort
def heap_sort(arr): 
    n = len(arr)

    # Build heap (rearrange array)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract an element from heap
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i] # swap
        heapify(arr, i, 0)

# Function to sort an array using 
# insertion sort
def insertion_sort(arr): 
    n = len(arr)
    for i in range(1, n): 
        key = arr[i]
        j = i-1
        # Move elements of arr[0..i-1], 
        # that are greater than key, 
        # to one position ahead of their 
        # current position
        while j >= 0 and key < arr[j] : 
                arr[j+1] = arr[j] 
                j -= 1
        arr[j+1] = key 

# Function for Selection sort
def selection_sort(arr): 
    n = len(arr)
    for i in range(n): 
        # Find the minimum element in 
        # unsorted array
        min_idx = i 
        for j in range(i+1, n): 
            if arr[j] < arr[min_idx]: 
                min_idx = j
                
        # Swap the found minimum element 
        # with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
