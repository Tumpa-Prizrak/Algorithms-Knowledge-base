# Решето Эратосфена

```cpp
vector<int> compute_primes(int n) {
    bool sieve[n + 1];
    vector<int> primes;
    
    for (int i = 2; i <= n; i++) {
        sieve[i] = true;
    }
 
    for (int i = 2; i <= n; i++) {
        if (sieve[i]) {
            primes.push_back(i);
            
            for (int j = i * i; j <= n; j += i) {
                sieve[j] = false;
            }
        }
    }
    
    return primes;
}
```

Это работает следующим образом:

1. Создайте список из n + 1 логических значений. Изначально все они получают значение True.
2. Начиная с 2, проверьте, помечено ли текущее число в сите как True. Если это так, то это простое число. Добавьте его в список простых чисел.
3. Отметьте в списке все значения, кратные текущему числу, как False. Это позволит "отсеять" не простые числа.
4. Повторяйте шаги 2 и 3, пока мы не дойдем до n.
5. Возвращает список простых чисел.

Временная сложность этого алгоритма равна *O(n log log n)*.

Визуализация данного алгоритма:
![РЭ](https://brestprog.by/topics/primesieve/eratosthenes.gif)
